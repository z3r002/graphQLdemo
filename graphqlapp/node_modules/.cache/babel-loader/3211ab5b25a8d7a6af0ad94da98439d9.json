{"ast":null,"code":"import devAssert from \"../jsutils/devAssert.mjs\";\nimport { GraphQLError } from \"../error/GraphQLError.mjs\";\nimport { visit, visitInParallel } from \"../language/visitor.mjs\";\nimport { assertValidSchema } from \"../type/validate.mjs\";\nimport { TypeInfo, visitWithTypeInfo } from \"../utilities/TypeInfo.mjs\";\nimport { specifiedRules, specifiedSDLRules } from \"./specifiedRules.mjs\";\nimport { SDLValidationContext, ValidationContext } from \"./ValidationContext.mjs\";\n/**\r\n * Implements the \"Validation\" section of the spec.\r\n *\r\n * Validation runs synchronously, returning an array of encountered errors, or\r\n * an empty array if no errors were encountered and the document is valid.\r\n *\r\n * A list of specific validation rules may be provided. If not provided, the\r\n * default list of rules defined by the GraphQL specification will be used.\r\n *\r\n * Each validation rules is a function which returns a visitor\r\n * (see the language/visitor API). Visitor methods are expected to return\r\n * GraphQLErrors, or Arrays of GraphQLErrors when invalid.\r\n *\r\n * Optionally a custom TypeInfo instance may be provided. If not provided, one\r\n * will be created from the provided schema.\r\n */\n\nexport function validate(schema, documentAST) {\n  var rules = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : specifiedRules;\n  var typeInfo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new TypeInfo(schema);\n  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {\n    maxErrors: undefined\n  };\n  documentAST || devAssert(0, 'Must provide document.'); // If the schema used for validation is invalid, throw an error.\n\n  assertValidSchema(schema);\n  var abortObj = Object.freeze({});\n  var errors = [];\n  var context = new ValidationContext(schema, documentAST, typeInfo, function (error) {\n    if (options.maxErrors != null && errors.length >= options.maxErrors) {\n      errors.push(new GraphQLError('Too many validation errors, error limit reached. Validation aborted.'));\n      throw abortObj;\n    }\n\n    errors.push(error);\n  }); // This uses a specialized visitor which runs multiple visitors in parallel,\n  // while maintaining the visitor skip and break API.\n\n  var visitor = visitInParallel(rules.map(function (rule) {\n    return rule(context);\n  })); // Visit the whole document with each instance of all provided rules.\n\n  try {\n    visit(documentAST, visitWithTypeInfo(typeInfo, visitor));\n  } catch (e) {\n    if (e !== abortObj) {\n      throw e;\n    }\n  }\n\n  return errors;\n}\n/**\r\n * @internal\r\n */\n\nexport function validateSDL(documentAST, schemaToExtend) {\n  var rules = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : specifiedSDLRules;\n  var errors = [];\n  var context = new SDLValidationContext(documentAST, schemaToExtend, function (error) {\n    errors.push(error);\n  });\n  var visitors = rules.map(function (rule) {\n    return rule(context);\n  });\n  visit(documentAST, visitInParallel(visitors));\n  return errors;\n}\n/**\r\n * Utility function which asserts a SDL document is valid by throwing an error\r\n * if it is invalid.\r\n *\r\n * @internal\r\n */\n\nexport function assertValidSDL(documentAST) {\n  var errors = validateSDL(documentAST);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map(function (error) {\n      return error.message;\n    }).join('\\n\\n'));\n  }\n}\n/**\r\n * Utility function which asserts a SDL document is valid by throwing an error\r\n * if it is invalid.\r\n *\r\n * @internal\r\n */\n\nexport function assertValidSDLExtension(documentAST, schema) {\n  var errors = validateSDL(documentAST, schema);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map(function (error) {\n      return error.message;\n    }).join('\\n\\n'));\n  }\n}","map":{"version":3,"sources":["D:/projects/graphQLdemo/graphqlapp/node_modules/graphql/validation/validate.mjs"],"names":["devAssert","GraphQLError","visit","visitInParallel","assertValidSchema","TypeInfo","visitWithTypeInfo","specifiedRules","specifiedSDLRules","SDLValidationContext","ValidationContext","validate","schema","documentAST","rules","arguments","length","undefined","typeInfo","options","maxErrors","abortObj","Object","freeze","errors","context","error","push","visitor","map","rule","e","validateSDL","schemaToExtend","visitors","assertValidSDL","Error","message","join","assertValidSDLExtension"],"mappings":"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","sourcesContent":["import devAssert from \"../jsutils/devAssert.mjs\";\r\nimport { GraphQLError } from \"../error/GraphQLError.mjs\";\r\nimport { visit, visitInParallel } from \"../language/visitor.mjs\";\r\nimport { assertValidSchema } from \"../type/validate.mjs\";\r\nimport { TypeInfo, visitWithTypeInfo } from \"../utilities/TypeInfo.mjs\";\r\nimport { specifiedRules, specifiedSDLRules } from \"./specifiedRules.mjs\";\r\nimport { SDLValidationContext, ValidationContext } from \"./ValidationContext.mjs\";\r\n/**\r\n * Implements the \"Validation\" section of the spec.\r\n *\r\n * Validation runs synchronously, returning an array of encountered errors, or\r\n * an empty array if no errors were encountered and the document is valid.\r\n *\r\n * A list of specific validation rules may be provided. If not provided, the\r\n * default list of rules defined by the GraphQL specification will be used.\r\n *\r\n * Each validation rules is a function which returns a visitor\r\n * (see the language/visitor API). Visitor methods are expected to return\r\n * GraphQLErrors, or Arrays of GraphQLErrors when invalid.\r\n *\r\n * Optionally a custom TypeInfo instance may be provided. If not provided, one\r\n * will be created from the provided schema.\r\n */\r\n\r\nexport function validate(schema, documentAST) {\r\n  var rules = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : specifiedRules;\r\n  var typeInfo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new TypeInfo(schema);\r\n  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {\r\n    maxErrors: undefined\r\n  };\r\n  documentAST || devAssert(0, 'Must provide document.'); // If the schema used for validation is invalid, throw an error.\r\n\r\n  assertValidSchema(schema);\r\n  var abortObj = Object.freeze({});\r\n  var errors = [];\r\n  var context = new ValidationContext(schema, documentAST, typeInfo, function (error) {\r\n    if (options.maxErrors != null && errors.length >= options.maxErrors) {\r\n      errors.push(new GraphQLError('Too many validation errors, error limit reached. Validation aborted.'));\r\n      throw abortObj;\r\n    }\r\n\r\n    errors.push(error);\r\n  }); // This uses a specialized visitor which runs multiple visitors in parallel,\r\n  // while maintaining the visitor skip and break API.\r\n\r\n  var visitor = visitInParallel(rules.map(function (rule) {\r\n    return rule(context);\r\n  })); // Visit the whole document with each instance of all provided rules.\r\n\r\n  try {\r\n    visit(documentAST, visitWithTypeInfo(typeInfo, visitor));\r\n  } catch (e) {\r\n    if (e !== abortObj) {\r\n      throw e;\r\n    }\r\n  }\r\n\r\n  return errors;\r\n}\r\n/**\r\n * @internal\r\n */\r\n\r\nexport function validateSDL(documentAST, schemaToExtend) {\r\n  var rules = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : specifiedSDLRules;\r\n  var errors = [];\r\n  var context = new SDLValidationContext(documentAST, schemaToExtend, function (error) {\r\n    errors.push(error);\r\n  });\r\n  var visitors = rules.map(function (rule) {\r\n    return rule(context);\r\n  });\r\n  visit(documentAST, visitInParallel(visitors));\r\n  return errors;\r\n}\r\n/**\r\n * Utility function which asserts a SDL document is valid by throwing an error\r\n * if it is invalid.\r\n *\r\n * @internal\r\n */\r\n\r\nexport function assertValidSDL(documentAST) {\r\n  var errors = validateSDL(documentAST);\r\n\r\n  if (errors.length !== 0) {\r\n    throw new Error(errors.map(function (error) {\r\n      return error.message;\r\n    }).join('\\n\\n'));\r\n  }\r\n}\r\n/**\r\n * Utility function which asserts a SDL document is valid by throwing an error\r\n * if it is invalid.\r\n *\r\n * @internal\r\n */\r\n\r\nexport function assertValidSDLExtension(documentAST, schema) {\r\n  var errors = validateSDL(documentAST, schema);\r\n\r\n  if (errors.length !== 0) {\r\n    throw new Error(errors.map(function (error) {\r\n      return error.message;\r\n    }).join('\\n\\n'));\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}