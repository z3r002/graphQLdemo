{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { invariant, InvariantError } from 'ts-invariant';\nimport { equal } from '@wry/equality';\nimport { createFragmentMap, getFragmentFromSelection, getDefaultValues, getFragmentDefinitions, getOperationDefinition, getTypenameFromResult, makeReference, isField, resultKeyNameFromField, isReference, shouldInclude, hasDirectives, cloneDeep } from \"../../utilities/index.js\";\nimport { makeProcessedFieldsMerger, fieldNameFromStoreName } from \"./helpers.js\";\n;\n\nvar StoreWriter = function () {\n  function StoreWriter(cache, reader) {\n    this.cache = cache;\n    this.reader = reader;\n  }\n\n  StoreWriter.prototype.writeToStore = function (_a) {\n    var query = _a.query,\n        result = _a.result,\n        dataId = _a.dataId,\n        store = _a.store,\n        variables = _a.variables;\n    var operationDefinition = getOperationDefinition(query);\n    var merger = makeProcessedFieldsMerger();\n    variables = __assign(__assign({}, getDefaultValues(operationDefinition)), variables);\n    var ref = this.processSelectionSet({\n      result: result || Object.create(null),\n      dataId: dataId,\n      selectionSet: operationDefinition.selectionSet,\n      context: {\n        store: store,\n        written: Object.create(null),\n        merge: function (existing, incoming) {\n          return merger.merge(existing, incoming);\n        },\n        variables: variables,\n        varString: JSON.stringify(variables),\n        fragmentMap: createFragmentMap(getFragmentDefinitions(query))\n      }\n    });\n\n    if (!isReference(ref)) {\n      throw process.env.NODE_ENV === \"production\" ? new InvariantError(7) : new InvariantError(\"Could not identify object \" + JSON.stringify(result));\n    }\n\n    store.retain(ref.__ref);\n    return ref;\n  };\n\n  StoreWriter.prototype.processSelectionSet = function (_a) {\n    var _this = this;\n\n    var dataId = _a.dataId,\n        result = _a.result,\n        selectionSet = _a.selectionSet,\n        context = _a.context,\n        _b = _a.out,\n        out = _b === void 0 ? {\n      shouldApplyMerges: false\n    } : _b;\n    var policies = this.cache.policies;\n\n    var _c = policies.identify(result, selectionSet, context.fragmentMap),\n        id = _c[0],\n        keyObject = _c[1];\n\n    dataId = dataId || id;\n\n    if (\"string\" === typeof dataId) {\n      var sets = context.written[dataId] || (context.written[dataId] = []);\n      var ref = makeReference(dataId);\n      if (sets.indexOf(selectionSet) >= 0) return ref;\n      sets.push(selectionSet);\n\n      if (this.reader && this.reader.isFresh(result, ref, selectionSet, context)) {\n        return ref;\n      }\n    }\n\n    var mergedFields = Object.create(null);\n\n    if (keyObject) {\n      mergedFields = context.merge(mergedFields, keyObject);\n    }\n\n    var typename = dataId && policies.rootTypenamesById[dataId] || getTypenameFromResult(result, selectionSet, context.fragmentMap) || dataId && context.store.get(dataId, \"__typename\");\n\n    if (\"string\" === typeof typename) {\n      mergedFields.__typename = typename;\n    }\n\n    var workSet = new Set(selectionSet.selections);\n    workSet.forEach(function (selection) {\n      var _a;\n\n      if (!shouldInclude(selection, context.variables)) return;\n\n      if (isField(selection)) {\n        var resultFieldKey = resultKeyNameFromField(selection);\n        var value = result[resultFieldKey];\n\n        if (typeof value !== 'undefined') {\n          var storeFieldName = policies.getStoreFieldName({\n            typename: typename,\n            fieldName: selection.name.value,\n            field: selection,\n            variables: context.variables\n          });\n\n          var incomingValue = _this.processFieldValue(value, selection, context, out);\n\n          if (policies.hasMergeFunction(typename, selection.name.value)) {\n            incomingValue = {\n              __field: selection,\n              __typename: typename,\n              __value: incomingValue\n            };\n            out.shouldApplyMerges = true;\n          }\n\n          mergedFields = context.merge(mergedFields, (_a = {}, _a[storeFieldName] = incomingValue, _a));\n        } else if (policies.usingPossibleTypes && !hasDirectives([\"defer\", \"client\"], selection)) {\n          throw process.env.NODE_ENV === \"production\" ? new InvariantError(8) : new InvariantError(\"Missing field '\" + resultFieldKey + \"' in \" + JSON.stringify(result, null, 2).substring(0, 100));\n        }\n      } else {\n        var fragment = getFragmentFromSelection(selection, context.fragmentMap);\n\n        if (fragment && policies.fragmentMatches(fragment, typename, result, context.variables)) {\n          fragment.selectionSet.selections.forEach(workSet.add, workSet);\n        }\n      }\n    });\n\n    if (\"string\" === typeof dataId) {\n      var entityRef_1 = makeReference(dataId);\n\n      if (out.shouldApplyMerges) {\n        mergedFields = policies.applyMerges(entityRef_1, mergedFields, context);\n      }\n\n      if (process.env.NODE_ENV !== \"production\") {\n        Object.keys(mergedFields).forEach(function (storeFieldName) {\n          var fieldName = fieldNameFromStoreName(storeFieldName);\n\n          if (!policies.hasMergeFunction(typename, fieldName)) {\n            warnAboutDataLoss(entityRef_1, mergedFields, storeFieldName, context.store);\n          }\n        });\n      }\n\n      context.store.merge(dataId, mergedFields);\n      return entityRef_1;\n    }\n\n    return mergedFields;\n  };\n\n  StoreWriter.prototype.processFieldValue = function (value, field, context, out) {\n    var _this = this;\n\n    if (!field.selectionSet || value === null) {\n      return process.env.NODE_ENV === 'production' ? value : cloneDeep(value);\n    }\n\n    if (Array.isArray(value)) {\n      return value.map(function (item) {\n        return _this.processFieldValue(item, field, context, out);\n      });\n    }\n\n    return this.processSelectionSet({\n      result: value,\n      selectionSet: field.selectionSet,\n      context: context,\n      out: out\n    });\n  };\n\n  return StoreWriter;\n}();\n\nexport { StoreWriter };\nvar warnings = new Set();\n\nfunction warnAboutDataLoss(existingRef, incomingObj, storeFieldName, store) {\n  var getChild = function (objOrRef) {\n    var child = store.getFieldValue(objOrRef, storeFieldName);\n    return typeof child === \"object\" && child;\n  };\n\n  var existing = getChild(existingRef);\n  if (!existing) return;\n  var incoming = getChild(incomingObj);\n  if (!incoming) return;\n  if (isReference(existing)) return;\n  if (equal(existing, incoming)) return;\n\n  if (Object.keys(existing).every(function (key) {\n    return store.getFieldValue(incoming, key) !== void 0;\n  })) {\n    return;\n  }\n\n  var parentType = store.getFieldValue(existingRef, \"__typename\") || store.getFieldValue(incomingObj, \"__typename\");\n  var fieldName = fieldNameFromStoreName(storeFieldName);\n  var typeDotName = parentType + \".\" + fieldName;\n  if (warnings.has(typeDotName)) return;\n  warnings.add(typeDotName);\n  var childTypenames = [];\n\n  if (!Array.isArray(existing) && !Array.isArray(incoming)) {\n    [existing, incoming].forEach(function (child) {\n      var typename = store.getFieldValue(child, \"__typename\");\n\n      if (typeof typename === \"string\" && !childTypenames.includes(typename)) {\n        childTypenames.push(typename);\n      }\n    });\n  }\n\n  process.env.NODE_ENV === \"production\" || invariant.warn(\"Cache data may be lost when replacing the \" + fieldName + \" field of a \" + parentType + \" object.\\n\\nTo address this problem (which is not a bug in Apollo Client), \" + (childTypenames.length ? \"either ensure all objects of type \" + childTypenames.join(\" and \") + \" have IDs, or \" : \"\") + \"define a custom merge function for the \" + typeDotName + \" field, so InMemoryCache can safely merge these objects:\\n\\n  existing: \" + JSON.stringify(existing).slice(0, 1000) + \"\\n  incoming: \" + JSON.stringify(incoming).slice(0, 1000) + \"\\n\\nFor more information about these options, please refer to the documentation:\\n\\n  * Ensuring entity objects have IDs: https://go.apollo.dev/c/generating-unique-identifiers\\n  * Defining custom merge functions: https://go.apollo.dev/c/merging-non-normalized-objects\\n\");\n}","map":{"version":3,"sources":["../../../src/cache/inmemory/writeToStore.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __assign } from \"tslib\";\r\nimport { invariant, InvariantError } from 'ts-invariant';\r\nimport { equal } from '@wry/equality';\r\nimport { createFragmentMap, getFragmentFromSelection, getDefaultValues, getFragmentDefinitions, getOperationDefinition, getTypenameFromResult, makeReference, isField, resultKeyNameFromField, isReference, shouldInclude, hasDirectives, cloneDeep, } from \"../../utilities/index.js\";\r\nimport { makeProcessedFieldsMerger, fieldNameFromStoreName } from \"./helpers.js\";\r\n;\r\nvar StoreWriter = (function () {\r\n    function StoreWriter(cache, reader) {\r\n        this.cache = cache;\r\n        this.reader = reader;\r\n    }\r\n    StoreWriter.prototype.writeToStore = function (_a) {\r\n        var query = _a.query, result = _a.result, dataId = _a.dataId, store = _a.store, variables = _a.variables;\r\n        var operationDefinition = getOperationDefinition(query);\r\n        var merger = makeProcessedFieldsMerger();\r\n        variables = __assign(__assign({}, getDefaultValues(operationDefinition)), variables);\r\n        var ref = this.processSelectionSet({\r\n            result: result || Object.create(null),\r\n            dataId: dataId,\r\n            selectionSet: operationDefinition.selectionSet,\r\n            context: {\r\n                store: store,\r\n                written: Object.create(null),\r\n                merge: function (existing, incoming) {\r\n                    return merger.merge(existing, incoming);\r\n                },\r\n                variables: variables,\r\n                varString: JSON.stringify(variables),\r\n                fragmentMap: createFragmentMap(getFragmentDefinitions(query)),\r\n            },\r\n        });\r\n        if (!isReference(ref)) {\r\n            throw process.env.NODE_ENV === \"production\" ? new InvariantError(7) : new InvariantError(\"Could not identify object \" + JSON.stringify(result));\r\n        }\r\n        store.retain(ref.__ref);\r\n        return ref;\r\n    };\r\n    StoreWriter.prototype.processSelectionSet = function (_a) {\r\n        var _this = this;\r\n        var dataId = _a.dataId, result = _a.result, selectionSet = _a.selectionSet, context = _a.context, _b = _a.out, out = _b === void 0 ? {\r\n            shouldApplyMerges: false,\r\n        } : _b;\r\n        var policies = this.cache.policies;\r\n        var _c = policies.identify(result, selectionSet, context.fragmentMap), id = _c[0], keyObject = _c[1];\r\n        dataId = dataId || id;\r\n        if (\"string\" === typeof dataId) {\r\n            var sets = context.written[dataId] || (context.written[dataId] = []);\r\n            var ref = makeReference(dataId);\r\n            if (sets.indexOf(selectionSet) >= 0)\r\n                return ref;\r\n            sets.push(selectionSet);\r\n            if (this.reader && this.reader.isFresh(result, ref, selectionSet, context)) {\r\n                return ref;\r\n            }\r\n        }\r\n        var mergedFields = Object.create(null);\r\n        if (keyObject) {\r\n            mergedFields = context.merge(mergedFields, keyObject);\r\n        }\r\n        var typename = (dataId && policies.rootTypenamesById[dataId]) ||\r\n            getTypenameFromResult(result, selectionSet, context.fragmentMap) ||\r\n            (dataId && context.store.get(dataId, \"__typename\"));\r\n        if (\"string\" === typeof typename) {\r\n            mergedFields.__typename = typename;\r\n        }\r\n        var workSet = new Set(selectionSet.selections);\r\n        workSet.forEach(function (selection) {\r\n            var _a;\r\n            if (!shouldInclude(selection, context.variables))\r\n                return;\r\n            if (isField(selection)) {\r\n                var resultFieldKey = resultKeyNameFromField(selection);\r\n                var value = result[resultFieldKey];\r\n                if (typeof value !== 'undefined') {\r\n                    var storeFieldName = policies.getStoreFieldName({\r\n                        typename: typename,\r\n                        fieldName: selection.name.value,\r\n                        field: selection,\r\n                        variables: context.variables,\r\n                    });\r\n                    var incomingValue = _this.processFieldValue(value, selection, context, out);\r\n                    if (policies.hasMergeFunction(typename, selection.name.value)) {\r\n                        incomingValue = {\r\n                            __field: selection,\r\n                            __typename: typename,\r\n                            __value: incomingValue,\r\n                        };\r\n                        out.shouldApplyMerges = true;\r\n                    }\r\n                    mergedFields = context.merge(mergedFields, (_a = {},\r\n                        _a[storeFieldName] = incomingValue,\r\n                        _a));\r\n                }\r\n                else if (policies.usingPossibleTypes &&\r\n                    !hasDirectives([\"defer\", \"client\"], selection)) {\r\n                    throw process.env.NODE_ENV === \"production\" ? new InvariantError(8) : new InvariantError(\"Missing field '\" + resultFieldKey + \"' in \" + JSON.stringify(result, null, 2).substring(0, 100));\r\n                }\r\n            }\r\n            else {\r\n                var fragment = getFragmentFromSelection(selection, context.fragmentMap);\r\n                if (fragment &&\r\n                    policies.fragmentMatches(fragment, typename, result, context.variables)) {\r\n                    fragment.selectionSet.selections.forEach(workSet.add, workSet);\r\n                }\r\n            }\r\n        });\r\n        if (\"string\" === typeof dataId) {\r\n            var entityRef_1 = makeReference(dataId);\r\n            if (out.shouldApplyMerges) {\r\n                mergedFields = policies.applyMerges(entityRef_1, mergedFields, context);\r\n            }\r\n            if (process.env.NODE_ENV !== \"production\") {\r\n                Object.keys(mergedFields).forEach(function (storeFieldName) {\r\n                    var fieldName = fieldNameFromStoreName(storeFieldName);\r\n                    if (!policies.hasMergeFunction(typename, fieldName)) {\r\n                        warnAboutDataLoss(entityRef_1, mergedFields, storeFieldName, context.store);\r\n                    }\r\n                });\r\n            }\r\n            context.store.merge(dataId, mergedFields);\r\n            return entityRef_1;\r\n        }\r\n        return mergedFields;\r\n    };\r\n    StoreWriter.prototype.processFieldValue = function (value, field, context, out) {\r\n        var _this = this;\r\n        if (!field.selectionSet || value === null) {\r\n            return process.env.NODE_ENV === 'production' ? value : cloneDeep(value);\r\n        }\r\n        if (Array.isArray(value)) {\r\n            return value.map(function (item) { return _this.processFieldValue(item, field, context, out); });\r\n        }\r\n        return this.processSelectionSet({\r\n            result: value,\r\n            selectionSet: field.selectionSet,\r\n            context: context,\r\n            out: out,\r\n        });\r\n    };\r\n    return StoreWriter;\r\n}());\r\nexport { StoreWriter };\r\nvar warnings = new Set();\r\nfunction warnAboutDataLoss(existingRef, incomingObj, storeFieldName, store) {\r\n    var getChild = function (objOrRef) {\r\n        var child = store.getFieldValue(objOrRef, storeFieldName);\r\n        return typeof child === \"object\" && child;\r\n    };\r\n    var existing = getChild(existingRef);\r\n    if (!existing)\r\n        return;\r\n    var incoming = getChild(incomingObj);\r\n    if (!incoming)\r\n        return;\r\n    if (isReference(existing))\r\n        return;\r\n    if (equal(existing, incoming))\r\n        return;\r\n    if (Object.keys(existing).every(function (key) { return store.getFieldValue(incoming, key) !== void 0; })) {\r\n        return;\r\n    }\r\n    var parentType = store.getFieldValue(existingRef, \"__typename\") ||\r\n        store.getFieldValue(incomingObj, \"__typename\");\r\n    var fieldName = fieldNameFromStoreName(storeFieldName);\r\n    var typeDotName = parentType + \".\" + fieldName;\r\n    if (warnings.has(typeDotName))\r\n        return;\r\n    warnings.add(typeDotName);\r\n    var childTypenames = [];\r\n    if (!Array.isArray(existing) &&\r\n        !Array.isArray(incoming)) {\r\n        [existing, incoming].forEach(function (child) {\r\n            var typename = store.getFieldValue(child, \"__typename\");\r\n            if (typeof typename === \"string\" &&\r\n                !childTypenames.includes(typename)) {\r\n                childTypenames.push(typename);\r\n            }\r\n        });\r\n    }\r\n    process.env.NODE_ENV === \"production\" || invariant.warn(\"Cache data may be lost when replacing the \" + fieldName + \" field of a \" + parentType + \" object.\\n\\nTo address this problem (which is not a bug in Apollo Client), \" + (childTypenames.length\r\n        ? \"either ensure all objects of type \" +\r\n            childTypenames.join(\" and \") + \" have IDs, or \"\r\n        : \"\") + \"define a custom merge function for the \" + typeDotName + \" field, so InMemoryCache can safely merge these objects:\\n\\n  existing: \" + JSON.stringify(existing).slice(0, 1000) + \"\\n  incoming: \" + JSON.stringify(incoming).slice(0, 1000) + \"\\n\\nFor more information about these options, please refer to the documentation:\\n\\n  * Ensuring entity objects have IDs: https://go.apollo.dev/c/generating-unique-identifiers\\n  * Defining custom merge functions: https://go.apollo.dev/c/merging-non-normalized-objects\\n\");\r\n}\r\n//# sourceMappingURL=writeToStore.js.map"]},"metadata":{},"sourceType":"module"}