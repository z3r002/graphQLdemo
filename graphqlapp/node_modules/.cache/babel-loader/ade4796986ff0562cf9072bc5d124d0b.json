{"ast":null,"code":"import didYouMean from \"../../jsutils/didYouMean.mjs\";\nimport suggestionList from \"../../jsutils/suggestionList.mjs\";\nimport { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { isTypeDefinitionNode, isTypeSystemDefinitionNode, isTypeSystemExtensionNode } from \"../../language/predicates.mjs\";\nimport { specifiedScalarTypes } from \"../../type/scalars.mjs\";\nimport { introspectionTypes } from \"../../type/introspection.mjs\";\n/**\r\n * Known type names\r\n *\r\n * A GraphQL document is only valid if referenced types (specifically\r\n * variable definitions and fragment conditions) are defined by the type schema.\r\n */\n\nexport function KnownTypeNamesRule(context) {\n  var schema = context.getSchema();\n  var existingTypesMap = schema ? schema.getTypeMap() : Object.create(null);\n  var definedTypes = Object.create(null);\n\n  for (var _i2 = 0, _context$getDocument$2 = context.getDocument().definitions; _i2 < _context$getDocument$2.length; _i2++) {\n    var def = _context$getDocument$2[_i2];\n\n    if (isTypeDefinitionNode(def)) {\n      definedTypes[def.name.value] = true;\n    }\n  }\n\n  var typeNames = Object.keys(existingTypesMap).concat(Object.keys(definedTypes));\n  return {\n    NamedType: function NamedType(node, _1, parent, _2, ancestors) {\n      var typeName = node.name.value;\n\n      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {\n        var _ancestors$;\n\n        var definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0 ? _ancestors$ : parent;\n        var isSDL = definitionNode != null && isSDLNode(definitionNode);\n\n        if (isSDL && isStandardTypeName(typeName)) {\n          return;\n        }\n\n        var suggestedTypes = suggestionList(typeName, isSDL ? standardTypeNames.concat(typeNames) : typeNames);\n        context.reportError(new GraphQLError(\"Unknown type \\\"\".concat(typeName, \"\\\".\") + didYouMean(suggestedTypes), node));\n      }\n    }\n  };\n}\nvar standardTypeNames = [].concat(specifiedScalarTypes, introspectionTypes).map(function (type) {\n  return type.name;\n});\n\nfunction isStandardTypeName(typeName) {\n  return standardTypeNames.indexOf(typeName) !== -1;\n}\n\nfunction isSDLNode(value) {\n  return !Array.isArray(value) && (isTypeSystemDefinitionNode(value) || isTypeSystemExtensionNode(value));\n}","map":{"version":3,"sources":["D:/projects/graphQLdemo/graphqlapp/node_modules/graphql/validation/rules/KnownTypeNamesRule.mjs"],"names":["didYouMean","suggestionList","GraphQLError","isTypeDefinitionNode","isTypeSystemDefinitionNode","isTypeSystemExtensionNode","specifiedScalarTypes","introspectionTypes","KnownTypeNamesRule","context","schema","getSchema","existingTypesMap","getTypeMap","Object","create","definedTypes","_i2","_context$getDocument$2","getDocument","definitions","length","def","name","value","typeNames","keys","concat","NamedType","node","_1","parent","_2","ancestors","typeName","_ancestors$","definitionNode","isSDL","isSDLNode","isStandardTypeName","suggestedTypes","standardTypeNames","reportError","map","type","indexOf","Array","isArray"],"mappings":"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","sourcesContent":["import didYouMean from \"../../jsutils/didYouMean.mjs\";\r\nimport suggestionList from \"../../jsutils/suggestionList.mjs\";\r\nimport { GraphQLError } from \"../../error/GraphQLError.mjs\";\r\nimport { isTypeDefinitionNode, isTypeSystemDefinitionNode, isTypeSystemExtensionNode } from \"../../language/predicates.mjs\";\r\nimport { specifiedScalarTypes } from \"../../type/scalars.mjs\";\r\nimport { introspectionTypes } from \"../../type/introspection.mjs\";\r\n\r\n/**\r\n * Known type names\r\n *\r\n * A GraphQL document is only valid if referenced types (specifically\r\n * variable definitions and fragment conditions) are defined by the type schema.\r\n */\r\nexport function KnownTypeNamesRule(context) {\r\n  var schema = context.getSchema();\r\n  var existingTypesMap = schema ? schema.getTypeMap() : Object.create(null);\r\n  var definedTypes = Object.create(null);\r\n\r\n  for (var _i2 = 0, _context$getDocument$2 = context.getDocument().definitions; _i2 < _context$getDocument$2.length; _i2++) {\r\n    var def = _context$getDocument$2[_i2];\r\n\r\n    if (isTypeDefinitionNode(def)) {\r\n      definedTypes[def.name.value] = true;\r\n    }\r\n  }\r\n\r\n  var typeNames = Object.keys(existingTypesMap).concat(Object.keys(definedTypes));\r\n  return {\r\n    NamedType: function NamedType(node, _1, parent, _2, ancestors) {\r\n      var typeName = node.name.value;\r\n\r\n      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {\r\n        var _ancestors$;\r\n\r\n        var definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0 ? _ancestors$ : parent;\r\n        var isSDL = definitionNode != null && isSDLNode(definitionNode);\r\n\r\n        if (isSDL && isStandardTypeName(typeName)) {\r\n          return;\r\n        }\r\n\r\n        var suggestedTypes = suggestionList(typeName, isSDL ? standardTypeNames.concat(typeNames) : typeNames);\r\n        context.reportError(new GraphQLError(\"Unknown type \\\"\".concat(typeName, \"\\\".\") + didYouMean(suggestedTypes), node));\r\n      }\r\n    }\r\n  };\r\n}\r\nvar standardTypeNames = [].concat(specifiedScalarTypes, introspectionTypes).map(function (type) {\r\n  return type.name;\r\n});\r\n\r\nfunction isStandardTypeName(typeName) {\r\n  return standardTypeNames.indexOf(typeName) !== -1;\r\n}\r\n\r\nfunction isSDLNode(value) {\r\n  return !Array.isArray(value) && (isTypeSystemDefinitionNode(value) || isTypeSystemExtensionNode(value));\r\n}\r\n"]},"metadata":{},"sourceType":"module"}